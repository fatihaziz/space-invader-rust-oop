use macroquad::prelude::*;
use macroquad::texture::Texture2D;

use crate::{
    entities::{
        bullet::{Bullet, BulletBy},
        enemy::Enemy,
        ship::Ship,
    },
    WINDOW_HEIGHT, WINDOW_WIDTH,
};

#[derive(Debug, Eq, PartialEq)]
pub enum GameState {
    CREATED,
    PLAYING,
    GAMEOVER,
    EXIT,
}
pub struct GameTexture {
    pub bg: Texture2D,
    pub ship: Texture2D,
    pub enemy: Texture2D,
    pub bullet: Texture2D,
}

pub struct Buff {
    pub ship_speed: f32,
    pub bullet_damage: f32,
    pub bullet_multiplier: f32,
    pub bullet_size: f32,
    pub score_multiplier: f32,
}

pub struct GameObject {
    pub state: GameState,
    pub ship: Option<Ship>,
    pub enemies_vec: Option<Vec<Enemy>>,
    pub bullets_vec: Option<Vec<Bullet>>,
    pub waves: f32,
    pub score: f32,
    pub high_score: f32,
    pub texture: GameTexture,
    pub buff: Option<Buff>,
}

pub async fn new_game() -> GameObject {
    let mut game_object = GameObject {
        state: GameState::CREATED,
        ship: None,
        bullets_vec: None,
        enemies_vec: None,
        waves: 1.0,
        score: 0.0,
        high_score: 0.0,
        texture: {
            GameTexture {
                bg: (Texture2D::from_file_with_format(include_bytes!("../assets/bg.png"), None)),
                ship: (Texture2D::from_file_with_format(
                    include_bytes!("../assets/ship.png"),
                    None,
                )),
                enemy: (Texture2D::from_file_with_format(
                    include_bytes!("../assets/enemy.png"),
                    None,
                )),
                bullet: (Texture2D::from_file_with_format(
                    include_bytes!("../assets/bullet.png"),
                    None,
                )),
            }
        },
        buff: None,
    };

    // initialize player's ship
    game_object.ship = Some(Ship::new(
        WINDOW_WIDTH / 2.0,
        WINDOW_HEIGHT - 60.0,
        WHITE,
        true,
        50.0,
        1.0,
    ));

    return game_object;
}

pub fn game_logic(game: &mut GameObject) {
    let ship = &mut game.ship.unwrap();
    // user input
    {
        if is_key_down(KeyCode::Left) || is_key_down(KeyCode::A) {
            ship.left();
        }
        if is_key_down(KeyCode::Right) || is_key_down(KeyCode::D) {
            ship.right();
        }
        if is_key_down(KeyCode::Up) || is_key_down(KeyCode::W) {
            ship.up();
        }
        if is_key_down(KeyCode::Down) || is_key_down(KeyCode::S) {
            ship.down();
        }

        // limiting ship position
        if ship.x < 0.0 {
            ship.x = 0.0;
        }
        if ship.x > WINDOW_WIDTH - ship.size {
            ship.x = WINDOW_WIDTH - ship.size;
        }
        if ship.y < 0.0 {
            ship.y = 0.0;
        }
        if ship.y > WINDOW_HEIGHT - ship.size {
            ship.y = WINDOW_HEIGHT - ship.size;
        }
    }

    // fire a bullet when press space
    {
        if is_key_pressed(KeyCode::Space) {
            let mut bullet = Bullet::new(
                (ship.x + ship.size / 2.0) - 5.0,
                ship.y,
                WHITE,
                10.0,
                0.5,
                1.0,
                BulletBy::PLAYER,
            );
            if let Some(buff) = &mut game.buff {
                bullet.damage = buff.bullet_damage;
            }
            if let Some(bullet_vec) = &mut game.bullets_vec {
                bullet_vec.push(bullet);
            } else {
                game.bullets_vec = Some(vec![bullet]);
            }
        }
    }

    // move the bullet towards up
    {
        if let Some(bullet_vec) = &mut game.bullets_vec {
            for bullet in bullet_vec {
                bullet.y -= bullet.speed;
            }
        }
        // if outside screen, remove it
        if let Some(bullet_vec) = &mut game.bullets_vec {
            bullet_vec.iter_mut().for_each(|bullet| {
                if bullet.y < 0.0 {
                    bullet.is_alive = false;
                }
            });
            bullet_vec.retain(|bullet| bullet.is_alive);
        }
    }

    let max_waves = 5.0;

    // enemy waves
    {
        // maintain enemies
        if let Some(enemies_vec) = &mut game.enemies_vec {
            // remove dead enemies
            enemies_vec.retain(|enemy| enemy.is_alive);

            for enemy in enemies_vec {
                // check if enemy is hit by bullet
                // not generated by copilot :(
                if let Some(bullet_vec) = &mut game.bullets_vec {
                    for bullet in bullet_vec {
                        if bullet.is_hit(*enemy) {
                            bullet.hit();
                            enemy.kill(*bullet);
                            if enemy.is_alive == false {
                                game.score += enemy.score;
                            }
                        }
                    }
                }

                enemy.moving(WINDOW_WIDTH)
            }
        }

        let mut score_multiplier = 1.0;
        if let Some(buff) = &mut game.buff {
            score_multiplier =
                score_multiplier + (buff.score_multiplier * (game.waves - 1.0) as f32);
        }

        if game.waves < 2.0 && game.waves <= max_waves
        // generate 20 enemies per rows, 5 rows
        {
            let enemies_vec = &mut game.enemies_vec;
            if enemies_vec.is_none() {
                let enemy_per_row = 1;
                let enemy_rows = 1;

                let mut enemy = Enemy::new(0.0, 0.0, WHITE, 50.0, 0.25, 1.0, 1.0);
                let mut enemies_vec = Vec::new();
                // generate enemies
                for i in 0..enemy_per_row {
                    for j in 0..enemy_rows {
                        enemy.x = (i as f32 * enemy.size * 1.0) + enemy.size;
                        enemy.y = (j as f32 * enemy.size * 1.0) + enemy.size - 0.0;
                        enemy.score = enemy.score * score_multiplier;
                        enemies_vec.push(enemy)
                    }
                }
                game.enemies_vec = Some(enemies_vec);
            }
        } else if game.waves < 4.0 && game.waves <= max_waves
        // generate 22 enemies per rows, 7 rows
        {
            let enemies_vec = &mut game.enemies_vec;
            if enemies_vec.is_none() {
                let enemy_per_row = 1;
                let enemy_rows = 1;

                let mut enemy = Enemy::new(0.0, 0.0, WHITE, 40.0, 0.5, 2.0, 1.0);

                let mut enemies_vec = Vec::new();
                // generate enemies
                for i in 0..enemy_per_row {
                    for j in 0..enemy_rows {
                        enemy.x = (i as f32 * enemy.size * 1.0) + enemy.size;
                        enemy.y = (j as f32 * enemy.size * 1.0) + enemy.size - 0.0;
                        enemy.score = enemy.score * score_multiplier;
                        enemies_vec.push(enemy)
                    }
                }
                game.enemies_vec = Some(enemies_vec);
            }
        } else {
            game.waves += 1.0;
            game.enemies_vec = None;
        }
    }

    // gameover, when no enemy waves left, or when an enemy hit ship, or when enemy goes window
    {
        if let Some(enemies_vec) = &mut game.enemies_vec.clone() {
            for enemy in enemies_vec {
                if enemy.y > WINDOW_HEIGHT - enemy.size {
                    game.state = GameState::GAMEOVER;
                }
                if enemy.x < ship.x + ship.size
                    && enemy.x + enemy.size > ship.x
                    && enemy.y < ship.y + ship.size
                    && enemy.y + enemy.size > ship.y
                {
                    game.state = GameState::GAMEOVER;
                }
            }
        }
        if game.enemies_vec.is_none() || game.enemies_vec.as_deref().unwrap().len() == 0 {
            if game.waves < max_waves {
                game.waves += 1.0;
                game.enemies_vec = None;
            } else {
                game.state = GameState::GAMEOVER;
            }
        }
    }

    game.ship = Some(ship.clone());
}
